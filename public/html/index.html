<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - geometry - cube</title>
		<meta charset="utf-8">
		<link rel="stylesheet" href="css/main.css">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/Projector.js"></script>
		<script src="js/CanvasRenderer.js"></script>
		<script src="js/stats.min.js"></script>

		<script>
			var cameraController;
			var container;
			var cutebox;
			var camera, scene, renderer;
			var currentSphere;
			var index = 0;
			materials = [];
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var insideSphere = false;
			var numSpheres = 0;
			var distance;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var button = document.createElement('BUTTON');
				var buttonArrow = document.createTextNode('>');
				button.appendChild(buttonArrow);
				button.id = "nextbutton";
				button.onclick = updateIndex;
				container.appendChild(button);

				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.style.opacity = '0.5';
				info.innerHTML = 'Double click to enter';
				container.appendChild( info );

				cutebox = document.createElement('div');
				cutebox.id = "cutebox";
				container.appendChild(cutebox);

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 55;
				camera.position.z = 250;

				imageArray = ['img/office.JPG', 'img/berkeleygarden.jpg', 'img/lake.jpg', 'img/duboce.jpg'];
			  //imageArray = ['img/berkeleygardenedit.jpg'];
				numSpheres = imageArray.length;
				sphereArray = [];
				meshSphereArray = [];

				cameraController = new CameraController (camera);
				geometry = new THREE.SphereGeometry(100, 32, 32);

				for (i=0; i<numSpheres; i++){
					materials.push(new THREE.MeshBasicMaterial({
						map: THREE.ImageUtils.loadTexture(imageArray[i])
					}));
					materials[i].transparent= true;
					sphereArray.push(new THREE.Mesh(geometry,materials[i]));
					sphereArray[i].position.set(300*i,0,0);
					sphereArray[i].name = "mainsphere";
				}

				//set the first sphere mesh
				currentSphere = sphereArray[0];
				scene.add(currentSphere);


				//adding my basic wiremesh spheres
				for (i=0; i<numSpheres; i++){
					// geometry = new THREE.SphereGeometry(105, 32, 32);
					// var geo = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry( geometry )
					//
					// var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } );
					//
					// let wireframe = new THREE.LineSegments( geo, mat );

					//scene.add( wireframe );
					meshSphereArray.push(new THREE.Mesh(
							new THREE.SphereGeometry(105, 32, 32),
							new THREE.MeshBasicMaterial({
								color : 0xffffff,
								wireframe : true
							})));
					meshSphereArray[i].position.set (300*i,0,0);
					scene.add(meshSphereArray[i]);
				}


				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				stats = new Stats();
				container.appendChild( stats.dom );
				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener('dblclick', onDoubleClick, false);
			}

			function updateIndex() {
				index++;
				cameraController.state = 0;
				cameraController.destination = 300*index;
				if(index > numSpheres-1) {
					index =0;
					cameraController.state = 2;
				}
			}

			//camera controller class that handles switching between spheres, and zooming in/out of spehres
			function CameraController (camera) {
    		this.camera = camera;
				this.destination = 0;
				this.state = -1;
				this.update = function() {
					switch(this.state) {
    				case 0:
							camera.position.x += 5;
							currentSphere.material.opacity = Math.max(0, currentSphere.material.opacity - 0.01);
							if (camera.position.x > this.destination) {
								var selectedObject = scene.getObjectByName("mainsphere");
								scene.remove(selectedObject);
								currentSphere = sphereArray[index];
								currentSphere.material.opacity = 0;
								scene.add(currentSphere);
								this.state = 1;
							}
        		break;

    				case 1:
							if (currentSphere.material.opacity < 1){
								currentSphere.material.opacity += 0.01;
							} else {
								this.state = -1;
							}
        		break;

						case 2:
							camera.position.x += 5;
							if( camera.position.x > numSpheres*300+100){
								camera.position.x  = -200;
							} else if (camera.position.x == 0){
								reset = false;
								var selectedObject = scene.getObjectByName("mainsphere");
								scene.remove(selectedObject);
								currentSphere = sphereArray[index];
								currentSphere.material.opacity = 0;
								scene.add(currentSphere);
								this.state = 1;
							}
						break;

						case 3:
							if (distance < 50){
								this.state = -1;
								currentSphere.material.opacity = 1.0;
								var blogtext = document.createElement( 'div' );
								blogtext.style.position = 'absolute';
								blogtext.id = 'blogtext';
								blogtext.innerHTML = 'NOW DISSOLVE ME <br> <br> two tabs on your tongue A herd of shepherds to herd the sheep, sleep now my only oneBroken sweethearts who sleep apart Both still pine for the others side spine, spoon as sleep starts And pulse to pulse, now shush She makes the sound, the sound the sea makes to calm me down <br> I am see-through, soap sliver youre so thin As I begin rubbing lathers up your state worsens on my skin And gold, fatless finger to lip, one two three four hush And pulse to pulse, now shush She makes the sound, the sound the sea makes to calm me down She makes the sound, the sound the sea makes. Im tired now ';
								container.appendChild( blogtext );
								container.removeChild(cutebox);
							} else if (distance < 90) {
								camera.position.sub(currentSphere.position).multiplyScalar(0.99).add(currentSphere.position);
								currentSphere.scale.x = -1;
								currentSphere.material.opacity += 0.05;
							} else if (distance > 90) {
								camera.position.sub(currentSphere.position).multiplyScalar(0.99).add(currentSphere.position);
								currentSphere.material.opacity = Math.max(0, currentSphere.material.opacity - 0.01);
							}
						break;

						case 4:
							if (distance > 250){
								this.state = -1;
								currentSphere.material.opacity = 1.0;
							} else if (distance < 130) {
								camera.position.sub(currentSphere.position).multiplyScalar(1.01).add(currentSphere.position);
								currentSphere.material.opacity = Math.max(0, currentSphere.material.opacity - 0.01);
							} else if (distance> 130) {
								camera.position.sub(currentSphere.position).multiplyScalar(1.01).add(currentSphere.position);
								currentSphere.scale.x = 1;
								currentSphere.material.opacity = Math.min(1, currentSphere.material.opacity + 0.015);
								var child = document.getElementById('blogtext');
								if (child) container.removeChild(child);
								container.appendChild(cutebox);
							}
						}
					}
				}


			function onDoubleClick() {
				if(insideSphere) {
					insideSphere = false;
					cameraController.state = 4;
				} else {
					insideSphere = true;
					cameraController.state = 3;
				}
			}

			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				stats.begin();
				render();
				stats.end();
			}

			function render() {
				let look = new THREE.Vector3(0,-50,-200);
			 	distance = camera.position.distanceTo(currentSphere.position);
				cameraController.update();
				camera.lookAt(look.add(camera.position));
				camera.updateProjectionMatrix();

				//rotate all spheres, always
				meshSphereArray.forEach(function(entry) {
    			entry.rotation.y = Date.now()*0.0001;
				});
				currentSphere.rotation.y = Date.now()*0.0001;

				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>
